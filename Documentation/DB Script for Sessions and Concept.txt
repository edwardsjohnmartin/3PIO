CREATE SEQUENCE public.sessions_id_seq
    INCREMENT 1
    START 92
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.sessions_id_seq
    OWNER TO postgres;

CREATE TABLE public.sessions
(
    id integer NOT NULL DEFAULT nextval('sessions_id_seq'::regclass),
    user_id integer NOT NULL,
    securable_id integer NOT NULL,
    activity_id integer NOT NULL,
    start_time timestamp without time zone NOT NULL,
    end_time timestamp without time zone NOT NULL,
    mouse_clicks integer NOT NULL DEFAULT 0,
    key_presses integer NOT NULL DEFAULT 0,
    times_ran integer NOT NULL DEFAULT 0,
    CONSTRAINT sessions_pkey PRIMARY KEY (id),
    CONSTRAINT sessions_securable_id_fkey FOREIGN KEY (securable_id)
        REFERENCES public.securables (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE public.sessions
    OWNER to postgres;

CREATE OR REPLACE FUNCTION public.sproc_read_concept_get_progress(
	id integer)
    RETURNS TABLE(user_id integer, user_name text, lesson_completion json, project_completed boolean) 
    LANGUAGE 'sql'

    COST 100
    VOLATILE SECURITY DEFINER 
    ROWS 1000
AS $BODY$

SELECT u.id AS user_id, u.name AS user_name, array_to_json(array_agg(ROW(l.id,
(
COALESCE((
SELECT COUNT(e.id) FROM lessons AS l2
JOIN exercises_to_lessons AS etl ON l.id = etl.lesson_id
JOIN exercises AS e ON e.id = etl.exercise_id
LEFT JOIN completion_status_to_exercise AS cste ON e.id = cste.exercise_id
WHERE l2.id = l.id AND cste.user_id = u.id AND cste.date_updated = (SELECT max(date_updated) FROM completion_status_to_exercise WHERE user_id = cste.user_id AND lesson_id = l.id AND exercise_id = e.id AND concept_id = c.id) AND  cste.completion_status_id = (SELECT id FROM completion_status WHERE importance = (SELECT min(importance) FROM completion_status)))
/
nullif(CAST((SELECT COUNT(e.id) FROM lessons AS l2
JOIN exercises_to_lessons AS etl ON l.id = etl.lesson_id
JOIN exercises AS e ON e.id = etl.exercise_id
WHERE l2.id = l.id) AS float), 0), 1))
)::key_value_pair ORDER BY ltc.lesson_number)) AS lesson_completion,
(SELECT EXISTS(SELECT * FROM project_code_files_for_users AS pcffu WHERE pcffu.user_id = u.id AND pcffu.concept_id = c.id)) AS project_completed
FROM concepts AS c
JOIN lessons_to_concepts AS ltc ON ltc.concept_id = c.id
JOIN lessons AS l ON l.id = ltc.lesson_id
JOIN users_to_sections AS uts ON c.section_id = uts.section_id
JOIN users AS u ON uts.user_id = u.id
WHERE c.id = sproc_read_concept_get_progress.id AND uts.participation_type_id = 1
GROUP BY c.id, u.id
ORDER BY u.name;

$BODY$;

ALTER FUNCTION public.sproc_read_concept_get_progress(integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.sproc_read_concept_get_project_completion(
	concept_id integer)
    RETURNS TABLE(user_id integer, user_name text, project_completed boolean) 
    LANGUAGE 'sql'

    COST 100
    VOLATILE SECURITY DEFINER 
    ROWS 1000
AS $BODY$

SELECT u.id AS user_id, u.name AS user_name, (SELECT EXISTS(SELECT pcffu.user_id FROM project_code_files_for_users AS pcffu WHERE pcffu.user_id = u.id AND pcffu.concept_id = sproc_read_concept_get_project_completion.concept_id) AS project_completed)
FROM concepts AS c
JOIN users_to_sections AS uts ON c.section_id = uts.section_id
JOIN users AS u ON uts.user_id = u.id
WHERE c.id = sproc_read_concept_get_project_completion.concept_id
AND NOT c.is_deleted
AND uts.participation_type_id = 1
ORDER BY u.name;

$BODY$;

ALTER FUNCTION public.sproc_read_concept_get_project_completion(integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.sproc_read_session_for_student(
	user_id integer)
    RETURNS TABLE(securable_id integer, activity_id integer, start_time timestamp without time zone, end_time timestamp without time zone, mouse_clicks integer, key_presses integer, times_ran integer) 
    LANGUAGE 'sql'

    COST 100
    VOLATILE SECURITY DEFINER 
    ROWS 1000
AS $BODY$

SELECT s.securable_id, s.activity_id, s.start_time, s.end_time, s.mouse_clicks, s.key_presses, s.times_ran
FROM sessions AS s
WHERE s.user_id = sproc_read_session_for_student.user_id
ORDER BY s.securable_id, s.activity_id

$BODY$;

ALTER FUNCTION public.sproc_read_session_for_student(integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.sproc_read_session_type_for_student(
	securable_id integer,
	user_id integer)
    RETURNS TABLE(securable_id integer, activity_id integer, start_time timestamp without time zone, end_time timestamp without time zone, mouse_clicks integer, key_presses integer, times_ran integer) 
    LANGUAGE 'sql'

    COST 100
    VOLATILE SECURITY DEFINER 
    ROWS 1000
AS $BODY$

SELECT s.securable_id, s.activity_id, s.start_time, s.end_time, s.mouse_clicks, s.key_presses, s.times_ran
FROM sessions AS s
WHERE s.user_id = sproc_read_session_type_for_student.user_id
AND s.securable_id = sproc_read_session_type_for_student.securable_id
ORDER BY s.securable_id, s.activity_id

$BODY$;

ALTER FUNCTION public.sproc_read_session_type_for_student(integer, integer)
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.sproc_write_session(
	user_id integer,
	securable_id integer,
	activity_id integer,
	start_time timestamp without time zone,
	end_time timestamp without time zone,
	mouse_clicks integer,
	key_presses integer,
	times_ran integer)
    RETURNS void
    LANGUAGE 'sql'

    COST 100
    VOLATILE SECURITY DEFINER 
    ROWS 0
AS $BODY$

INSERT INTO sessions AS s 
(user_id, securable_id, activity_id, start_time, end_time, mouse_clicks, key_presses, times_ran)
VALUES (sproc_write_session.user_id,
        sproc_write_session.securable_id,
        sproc_write_session.activity_id,
        sproc_write_session.start_time,
        sproc_write_session.end_time,
        sproc_write_session.mouse_clicks,
        sproc_write_session.key_presses,
        sproc_write_session.times_ran);

$BODY$;

ALTER FUNCTION public.sproc_write_session(integer, integer, integer, timestamp without time zone, timestamp without time zone, integer, integer, integer)
    OWNER TO postgres;



