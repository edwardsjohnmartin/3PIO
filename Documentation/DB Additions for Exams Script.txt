CREATE TYPE question_score AS (
	question_id integer,
	score real
);


ALTER TYPE question_score OWNER TO postgres;

CREATE TYPE question_type AS (
	id integer,
	name text,
	weight integer
);


ALTER TYPE question_type OWNER TO postgres;

CREATE SEQUENCE exams_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exams_id_seq OWNER TO postgres;

CREATE TABLE exams (
    id integer DEFAULT nextval('exams_id_seq'::regclass) NOT NULL,
    name text NOT NULL,
    instructions text NOT NULL,
    owner_id integer NOT NULL,
    is_deleted boolean DEFAULT false NOT NULL,
    section_id integer NOT NULL
);


ALTER TABLE exams OWNER TO postgres;

CREATE SEQUENCE questions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE questions_id_seq OWNER TO postgres;

CREATE TABLE questions (
    id integer DEFAULT nextval('questions_id_seq'::regclass) NOT NULL,
    name text NOT NULL,
    instructions text NOT NULL,
    start_code text NOT NULL,
    test_code text NOT NULL,
    language_id integer NOT NULL,
    exam_id integer NOT NULL,
    weight integer DEFAULT 0 NOT NULL,
    is_deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE questions OWNER TO postgres;

CREATE SEQUENCE students_answers_to_questions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE students_answers_to_questions_id_seq OWNER TO postgres;

CREATE TABLE students_answers_to_questions (
    id integer DEFAULT nextval('students_answers_to_questions_id_seq'::regclass) NOT NULL,
    user_id integer NOT NULL,
    question_id integer NOT NULL,
    exam_id integer NOT NULL,
    score real DEFAULT 0 NOT NULL,
    contents text,
    completion_status_id integer NOT NULL,
    date_updated timestamp without time zone NOT NULL,
    is_deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE students_answers_to_questions OWNER TO postgres;

CREATE TABLE user_left_page_occurrences (
    user_id integer NOT NULL,
    question_id integer NOT NULL,
    exam_id integer NOT NULL,
    date_of_occurrence timestamp without time zone NOT NULL,
    is_deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE user_left_page_occurrences OWNER TO postgres;

CREATE TABLE users_to_exams (
    user_id integer NOT NULL,
    exam_id integer NOT NULL,
    start_time timestamp without time zone NOT NULL,
    close_time timestamp without time zone NOT NULL
);


ALTER TABLE users_to_exams OWNER TO postgres;

ALTER TABLE ONLY exams
    ADD CONSTRAINT exams_pkey PRIMARY KEY (id);

ALTER TABLE ONLY questions
    ADD CONSTRAINT questions_pkey PRIMARY KEY (id);

ALTER TABLE ONLY students_answers_to_questions
    ADD CONSTRAINT students_answers_to_questions_pkey PRIMARY KEY (id);

ALTER TABLE ONLY users_to_exams
    ADD CONSTRAINT user_to_exam_uq UNIQUE (user_id, exam_id);

ALTER TABLE ONLY students_answers_to_questions
    ADD CONSTRAINT user_to_question_to_exam_uq UNIQUE (user_id, question_id, exam_id);

ALTER TABLE ONLY exams
    ADD CONSTRAINT exams_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES users(id);

ALTER TABLE ONLY exams
    ADD CONSTRAINT exams_section_id_fkey FOREIGN KEY (section_id) REFERENCES sections(id);

ALTER TABLE ONLY questions
    ADD CONSTRAINT questions_exam_id_fkey FOREIGN KEY (exam_id) REFERENCES exams(id);

ALTER TABLE ONLY questions
    ADD CONSTRAINT questions_language_id_fkey FOREIGN KEY (language_id) REFERENCES languages(id);

ALTER TABLE ONLY students_answers_to_questions
    ADD CONSTRAINT students_answers_to_questions_completion_status_id_fkey FOREIGN KEY (completion_status_id) REFERENCES completion_status(id);


ALTER TABLE ONLY students_answers_to_questions
    ADD CONSTRAINT students_answers_to_questions_exam_id_fkey FOREIGN KEY (exam_id) REFERENCES exams(id);


ALTER TABLE ONLY students_answers_to_questions
    ADD CONSTRAINT students_answers_to_questions_question_id_fkey FOREIGN KEY (question_id) REFERENCES questions(id);

ALTER TABLE ONLY user_left_page_occurrences
    ADD CONSTRAINT user_left_page_occurrences_exam_id_fkey FOREIGN KEY (exam_id) REFERENCES exams(id);


ALTER TABLE ONLY user_left_page_occurrences
    ADD CONSTRAINT user_left_page_occurrences_question_id_fkey FOREIGN KEY (question_id) REFERENCES questions(id);


ALTER TABLE ONLY user_left_page_occurrences
    ADD CONSTRAINT user_left_page_occurrences_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id);


ALTER TABLE ONLY users_to_exams
    ADD CONSTRAINT users_to_exams_exam_id_fkey FOREIGN KEY (exam_id) REFERENCES exams(id);


ALTER TABLE ONLY users_to_exams
    ADD CONSTRAINT users_to_exams_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id);

CREATE FUNCTION sproc_read_exam_get(id integer) RETURNS TABLE(id integer, name text, instructions text, owner json, section json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT x.id, x.name, x.instructions, row_to_json(ROW(u.id, u.name)::key_value_pair) AS owner, row_to_json(ROW(s.id, s.name)::key_value_pair) AS section
FROM exams x
INNER JOIN users u ON (x.owner_id = u.id)
INNER JOIN sections s ON (x.section_id = s.id)
WHERE x.id = sproc_read_exam_get.id AND NOT x.is_deleted
GROUP BY x.id, u.id, s.id;

$$;


ALTER FUNCTION public.sproc_read_exam_get(id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_all_for_section_and_student(section_id integer, user_id integer) RETURNS TABLE(id integer, name text, start_time timestamp without time zone, close_time timestamp without time zone)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT utx.exam_id, x.name, utx.start_time, utx.close_time
FROM users_to_exams utx
INNER JOIN exams x ON (utx.exam_id = x.id)

WHERE x.section_id = sproc_read_exam_get_all_for_section_and_student.section_id AND NOT x.is_deleted
AND utx.user_id = sproc_read_exam_get_all_for_section_and_student.user_id;

$$;


ALTER FUNCTION public.sproc_read_exam_get_all_for_section_and_student(section_id integer, user_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_for_student(exam_id integer, user_id integer) RETURNS TABLE(id integer, name text, instructions text, owner json, section json, questions json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT x.id, x.name, x.instructions, 
    row_to_json(ROW(u.id, u.name)::key_value_pair) AS owner,
    row_to_json(ROW(s.id, s.name)::key_value_pair) AS section,
    array_to_json(array_agg(ROW(
        q.id, COALESCE(NULLIF(q.name, ''), q.instructions), 
        satq.completion_status_id)
    ::key_value_status ORDER BY q.id)) AS questions
FROM exams AS x
INNER JOIN users u ON (x.owner_id = u.id)
JOIN questions AS q ON sproc_read_exam_get_for_student.exam_id = q.exam_id
JOIN sections AS s ON (x.section_id = s.id)
LEFT JOIN students_answers_to_questions AS satq 
    ON satq.question_id = q.id 
    AND satq.user_id = sproc_read_exam_get_for_student.user_id 
    AND satq.exam_id = x.id 
WHERE x.id = sproc_read_exam_get_for_student.exam_id
GROUP BY x.id, u.id, s.id
ORDER BY x.id;

$$;


ALTER FUNCTION public.sproc_read_exam_get_for_student(exam_id integer, user_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_pairs() RETURNS SETOF key_value_pair
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT x.id, x.name FROM exams AS x WHERE NOT x.is_deleted
ORDER BY x.id;

$$;


ALTER FUNCTION public.sproc_read_exam_get_pairs() OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_pairs_for_owner(owner_id integer) RETURNS SETOF key_value_pair
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT x.id, x.name FROM exams AS x WHERE NOT x.is_deleted AND x.owner_id = sproc_read_exam_get_pairs_for_owner.owner_id
ORDER BY x.id;

$$;


ALTER FUNCTION public.sproc_read_exam_get_pairs_for_owner(owner_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_times(exam_id integer) RETURNS TABLE(name text, start_time timestamp without time zone, close_time timestamp without time zone)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT u.name, utx.start_time, utx.close_time
FROM users AS u
INNER JOIN users_to_exams utx ON (sproc_read_exam_get_times.exam_id = utx.exam_id)
WHERE u.id = utx.user_id
AND NOT u.is_deleted
GROUP BY u.name, utx.start_time, utx.close_time

$$;


ALTER FUNCTION public.sproc_read_exam_get_times(exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_times_for_student(exam_id integer, user_id integer) RETURNS TABLE(start_time timestamp without time zone, close_time timestamp without time zone)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT utx.start_time, utx.close_time
FROM users_to_exams AS utx
WHERE utx.exam_id = sproc_read_exam_get_times_for_student.exam_id
AND utx.user_id = sproc_read_exam_get_times_for_student.user_id;

$$;


ALTER FUNCTION public.sproc_read_exam_get_times_for_student(exam_id integer, user_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_get_total_weight(exam_id integer) RETURNS bigint
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT SUM (weight) AS total_weight
FROM questions AS q
WHERE q.exam_id = sproc_read_exam_get_total_weight.exam_id
AND NOT	q.is_deleted;

$$;


ALTER FUNCTION public.sproc_read_exam_get_total_weight(exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exam_scores(exam_id integer) RETURNS TABLE(student integer, scores json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT satq.user_id, array_to_json(array_agg(ROW(satq.question_id, satq.score)::question_score)) AS scores
FROM students_answers_to_questions AS satq
WHERE satq.exam_id = sproc_read_exam_scores.exam_id
GROUP BY satq.user_id;

$$;


ALTER FUNCTION public.sproc_read_exam_scores(exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_exams_for_section(section_id integer) RETURNS TABLE(id integer, name text, questions json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT 
x.id, x.name, 
array_to_json(array_agg(ROW(q.id, q.name, q.weight)::question_type ORDER BY q.id)) AS questions
FROM exams AS x 
LEFT JOIN questions AS q
	ON q.exam_id = x.id
WHERE NOT q.is_deleted 
AND NOT x.is_deleted
AND x.section_id = sproc_read_exams_for_section.section_id
GROUP BY x.id;

$$;


ALTER FUNCTION public.sproc_read_exams_for_section(section_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_get_left_page_occurrences_for_user_and_exam(user_id integer, exam_id integer) RETURNS TABLE(user_id integer, question_id integer, exam_id integer, date_of_occurrence timestamp without time zone)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT user_id, question_id, exam_id, date_of_occurrence
FROM user_left_page_occurrences 
WHERE sproc_read_get_left_page_occurrences_for_user_and_exam.user_id = user_id
AND sproc_read_get_left_page_occurrences_for_user_and_exam.exam_id = exam_id;

$$;


ALTER FUNCTION public.sproc_read_get_left_page_occurrences_for_user_and_exam(user_id integer, exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_question_get(id integer) RETURNS TABLE(id integer, name text, instructions text, start_code text, test_code text, language json, exam json, weight integer)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT q.id, q.name, q.instructions, q.start_code, q.test_code, row_to_json(ROW(l.id, l.name)::key_value_pair) AS language, row_to_json(ROW(x.id, x.name)::key_value_pair) AS exam, weight AS integer
FROM questions q
INNER JOIN languages l ON (q.language_id = l.id)
LEFT JOIN exams AS x ON q.exam_id = x.id
WHERE q.id = sproc_read_question_get.id AND NOT q.is_deleted
GROUP BY q.id, x.id, l.id; -- is this group by stuff correct?

$$;


ALTER FUNCTION public.sproc_read_question_get(id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_question_get_pairs() RETURNS SETOF key_value_pair
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT q.id, q.name FROM questions AS q WHERE NOT q.is_deleted
ORDER BY q.id;

$$;


ALTER FUNCTION public.sproc_read_question_get_pairs() OWNER TO postgres;

CREATE FUNCTION sproc_read_question_get_pairs_for_exam(exam_id integer) RETURNS SETOF key_value_pair
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT q.id, COALESCE(NULLIF(q.name, ''), q.instructions) FROM questions AS q
WHERE NOT q.is_deleted AND q.exam_id = sproc_read_question_get_pairs_for_exam.exam_id
GROUP BY q.id
ORDER BY q.id;

$$;


ALTER FUNCTION public.sproc_read_question_get_pairs_for_exam(exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_question_get_pairs_for_owner(owner_id integer) RETURNS SETOF key_value_pair
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT q.id, COALESCE(NULLIF(q.name, ''), q.instructions) FROM questions AS q
JOIN exams AS x ON x.id = q.exam_id
WHERE NOT q.is_deleted AND x.owner_id = sproc_read_question_get_pairs_for_owner.owner_id
GROUP BY q.id
ORDER BY q.id;

$$;


ALTER FUNCTION public.sproc_read_question_get_pairs_for_owner(owner_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_question_get_student_answer(question_id integer, exam_id integer, user_id integer) RETURNS TABLE(contents text)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT satq.contents 
FROM students_answers_to_questions AS satq 
WHERE satq.question_id = sproc_read_question_get_student_answer.question_id 
AND satq.exam_id = sproc_read_question_get_student_answer.exam_id 
AND satq.user_id = sproc_read_question_get_student_answer.user_id 
AND NOT satq.is_deleted

$$;


ALTER FUNCTION public.sproc_read_question_get_student_answer(question_id integer, exam_id integer, user_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_section_get_students(owner_id integer) RETURNS TABLE(id integer, name text, students json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT 
s.id, s.name, 
array_to_json(array_agg(ROW(u.id, u.name)::key_value_pair)) AS students
FROM sections AS s 
LEFT JOIN users_to_sections AS uts 
	ON s.id = uts.section_id AND uts.participation_type_id = 1 
LEFT JOIN users AS u 
	ON uts.user_id = u.id
WHERE NOT s.is_deleted 
AND s.teacher_id = sproc_read_section_get_students.owner_id
GROUP BY s.id;

$$;


ALTER FUNCTION public.sproc_read_section_get_students(owner_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_section_get_students_and_exams(owner_id integer) RETURNS TABLE(id integer, name text, students json, exams json)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT 
s.id, s.name, 
array_to_json(array_agg(ROW(u.id, u.name))) AS students,
array_to_json(array_agg(ROW(x.id, x.name))) AS exams
FROM sections AS s 
LEFT JOIN users_to_sections AS uts 
	ON s.id = uts.section_id AND uts.participation_type_id = 1 
LEFT JOIN users AS u 
	ON uts.user_id = u.id
LEFT JOIN exams AS x
	ON s.id = x.section_id
WHERE NOT s.is_deleted 
AND s.teacher_id = sproc_read_section_get_students_and_exams.owner_id
GROUP BY s.id;

$$;


ALTER FUNCTION public.sproc_read_section_get_students_and_exams(owner_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_read_user_get_grades_for_exam(user_id integer, exam_id integer) RETURNS TABLE(question_id integer, score real)
    LANGUAGE sql SECURITY DEFINER
    AS $$

SELECT 
satq.id, satq.score
FROM students_answers_to_questions AS satq 
WHERE NOT satq.is_deleted 
AND satq.user_id = sproc_read_user_get_grades_for_exam.user_id
AND satq.exam_id = sproc_read_user_get_grades_for_exam.exam_id;

$$;


ALTER FUNCTION public.sproc_read_user_get_grades_for_exam(user_id integer, exam_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_exam_create(name text, instructions text, owner integer, section integer) RETURNS TABLE(id integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE
ret_id int;
BEGIN
INSERT INTO exams AS x (name, instructions, section_id, owner_id)
VALUES (sproc_write_exam_create.name, sproc_write_exam_create.instructions, sproc_write_exam_create.section, sproc_write_exam_create.owner) RETURNING x.id into ret_id;
RETURN QUERY SELECT ret_id AS id;
END

$$;


ALTER FUNCTION public.sproc_write_exam_create(name text, instructions text, owner integer, section integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_exam_update(id integer, name text, instructions text, section integer) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$

UPDATE exams AS x
SET name = sproc_write_exam_update.name,
instructions = sproc_write_exam_update.instructions,
section_id = sproc_write_exam_update.section
WHERE x.id = sproc_write_exam_update.id;

$$;


ALTER FUNCTION public.sproc_write_exam_update(id integer, name text, instructions text, section integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_exam_update_times(students integer[], exam_id integer, start_time timestamp without time zone, close_time timestamp without time zone) RETURNS TABLE(id integer)
    LANGUAGE sql SECURITY DEFINER
    AS $$

INSERT INTO users_to_exams (user_id, exam_id, start_time, close_time)
SELECT u, sproc_write_exam_update_times.exam_id, sproc_write_exam_update_times.start_time, sproc_write_exam_update_times.close_time
FROM unnest(sproc_write_exam_update_times.students) AS u
ON CONFLICT ON CONSTRAINT user_to_exam_uq
DO UPDATE SET 
    start_time = sproc_write_exam_update_times.start_time,
    close_time = sproc_write_exam_update_times.close_time
RETURNING users_to_exams.user_id

$$;


ALTER FUNCTION public.sproc_write_exam_update_times(students integer[], exam_id integer, start_time timestamp without time zone, close_time timestamp without time zone) OWNER TO postgres;

CREATE FUNCTION sproc_write_question_create(name text, instructions text, start_code text, test_code text, language integer, exam integer, weight integer) RETURNS TABLE(id integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE
ret_id int;
BEGIN
INSERT INTO questions AS q (name, instructions, start_code, test_code, language_id, exam_id, weight)
VALUES (sproc_write_question_create.name, sproc_write_question_create.instructions, sproc_write_question_create.start_code, sproc_write_question_create.test_code, sproc_write_question_create.language, sproc_write_question_create.exam, sproc_write_question_create.weight) RETURNING q.id INTO ret_id;
RETURN QUERY SELECT ret_id AS id;
END

$$;


ALTER FUNCTION public.sproc_write_question_create(name text, instructions text, start_code text, test_code text, language integer, exam integer, weight integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_question_update(id integer, name text, instructions text, start_code text, test_code text, language integer, exam integer, weight integer) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$

UPDATE questions AS q
SET name = sproc_write_question_update.name,
instructions = sproc_write_question_update.instructions,
start_code = sproc_write_question_update.start_code,
test_code = sproc_write_question_update.test_code,
language_id = sproc_write_question_update.language,
exam_id = sproc_write_question_update.exam,
weight = sproc_write_question_update.weight
WHERE q.id = sproc_write_question_update.id;

$$;


ALTER FUNCTION public.sproc_write_question_update(id integer, name text, instructions text, start_code text, test_code text, language integer, exam integer, weight integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_question_update_student_answer(question_id integer, exam_id integer, user_id integer, contents text) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$

INSERT INTO students_answers_to_questions (question_id, exam_id, user_id, contents) 
VALUES 
(
    sproc_write_question_update_student_answer.question_id, 
    sproc_write_question_update_student_answer.exam_id, 
    sproc_write_question_update_student_answer.user_id, 
    sproc_write_question_update_student_answer.contents
)
ON CONFLICT ON CONSTRAINT user_to_question_to_exam_uq
DO 
	UPDATE 
    	SET contents = sproc_write_question_update_student_answer.contents
		WHERE students_answers_to_questions.user_id = sproc_write_question_update_student_answer.user_id 
    	AND students_answers_to_questions.question_id = sproc_write_question_update_student_answer.question_id
    	AND students_answers_to_questions.exam_id = sproc_write_question_update_student_answer.exam_id;

$$;


ALTER FUNCTION public.sproc_write_question_update_student_answer(question_id integer, exam_id integer, user_id integer, contents text) OWNER TO postgres;

CREATE FUNCTION sproc_write_question_update_student_answer(question_id integer, exam_id integer, user_id integer, contents text, completion_status_id integer) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$

INSERT INTO students_answers_to_questions (question_id, exam_id, user_id, contents, completion_status_id, date_updated, score) 
VALUES 
(
    sproc_write_question_update_student_answer.question_id, 
    sproc_write_question_update_student_answer.exam_id, 
    sproc_write_question_update_student_answer.user_id, 
    sproc_write_question_update_student_answer.contents,
    sproc_write_question_update_student_answer.completion_status_id,
    current_timestamp,
    CASE 
    	WHEN sproc_write_question_update_student_answer.completion_status_id = 1 
    		THEN 1
    		ELSE .5
    END
)
ON CONFLICT ON CONSTRAINT user_to_question_to_exam_uq
DO 
	UPDATE 
    	SET contents = sproc_write_question_update_student_answer.contents,
        	date_updated = current_timestamp,
            completion_status_id = sproc_write_question_update_student_answer.completion_status_id,
            score = (
            SELECT CASE 
        		WHEN sproc_write_question_update_student_answer.completion_status_id = 1
            		THEN 1
                	ELSE 0
        	END)
		WHERE students_answers_to_questions.user_id = sproc_write_question_update_student_answer.user_id 
    	AND students_answers_to_questions.question_id = sproc_write_question_update_student_answer.question_id
    	AND students_answers_to_questions.exam_id = sproc_write_question_update_student_answer.exam_id;

$$;


ALTER FUNCTION public.sproc_write_question_update_student_answer(question_id integer, exam_id integer, user_id integer, contents text, completion_status_id integer) OWNER TO postgres;

CREATE FUNCTION sproc_write_user_left_page_occurrence_create(user_id integer, question_id integer, exam_id integer, date_of_occurrence timestamp without time zone) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$

INSERT INTO user_left_page_occurrences AS ulpo 
(user_id, question_id, exam_id, date_of_occurrence)
VALUES (sproc_write_user_left_page_occurrence_create.user_id,
        sproc_write_user_left_page_occurrence_create.question_id,
        sproc_write_user_left_page_occurrence_create.exam_id,
        sproc_write_user_left_page_occurrence_create.date_of_occurrence);

$$;


ALTER FUNCTION public.sproc_write_user_left_page_occurrence_create(user_id integer, question_id integer, exam_id integer, date_of_occurrence timestamp without time zone) OWNER TO postgres;


INSERT INTO securables (name, is_deleted) VALUES ('Exam', false),('Question', false);

INSERT INTO permissions_to_roles (role_id,permission_type_id,securable_id) VALUES (1,1,12),(1,1,13),(1,2,12),(1,2,13),(1,3,12),(1,3,13),(1,4,12),(1,4,13),(1,5,12),(1,5,13),(2,1,12),(2,1,13),(2,2,12),(2,2,13),(2,3,12),(2,3,13),(2,4,12),(2,4,13),(2,5,12),(2,5,13),(3,1,12),(3,1,13);
